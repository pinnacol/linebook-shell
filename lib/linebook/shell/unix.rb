require 'erb'

# Generated by Linecook, do not edit.
module Linebook
module Shell
module Unix
require 'linebook/shell/posix'
include Posix

def shell_path
  @shell_path ||= '/bin/sh'
end

def env_path
  @env_path ||= '/usr/bin/env'
end

def target_path(source_path)
  '$LINECOOK_DIR/%s' % super(source_path)
end

def to_opts(opts)
  if opts.nil? || opts.empty?
    return ''
  end
  
  args = [nil]
  
  opts.keys.sort.each do |key|
    opt = key.to_s
    
    unless opt[0] == ?-
      opt = opt.length == 1 ? "-#{opt}" : "--#{opt}"
    end
    
    args << opt
    args << opts[key]
  end
  
  args.join(' ')
end

def close
  unless closed?
    section " (#{target_name}) "
  end
  
  super
end
################################### cat ###################################

# :stopdoc:
CAT_LINE = __LINE__ + 2
CAT = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
cat<% sources.each do |source| %> "<%= source %>"<% end %>
END_OF_TEMPLATE
# :startdoc:

# Executes 'cat' with the sources.
# ==== CAT ERB
#   cat<% sources.each do |source| %> "<%= source %>"<% end %>
def cat(*sources)
  eval(CAT, binding, __FILE__, CAT_LINE)
  nil
end

def _cat(*args, &block) # :nodoc:
  capture { cat(*args, &block) }
end

################################# chmod #################################

# :stopdoc:
CHMOD_LINE = __LINE__ + 2
CHMOD = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% if mode %>
chmod <%= mode %> "<%= target %>"
<% check_status %>
<% end %>
END_OF_TEMPLATE
# :startdoc:

# 
# ==== CHMOD ERB
#   <% if mode %>
#   chmod <%= mode %> "<%= target %>"
#   <% check_status %>
#   <% end %>
def chmod(mode, target)
  eval(CHMOD, binding, __FILE__, CHMOD_LINE)
  nil
end

def _chmod(*args, &block) # :nodoc:
  capture { chmod(*args, &block) }
end

################################# chown #################################

# :stopdoc:
CHOWN_LINE = __LINE__ + 2
CHOWN = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% if user || group %>
chown <%= user %>:<%= group %> "<%= target %>"
<% check_status %>
<% end %>
END_OF_TEMPLATE
# :startdoc:

# 
# ==== CHOWN ERB
#   <% if user || group %>
#   chown <%= user %>:<%= group %> "<%= target %>"
#   <% check_status %>
#   <% end %>
def chown(user, group, target)
  eval(CHOWN, binding, __FILE__, CHOWN_LINE)
  nil
end

def _chown(*args, &block) # :nodoc:
  capture { chown(*args, &block) }
end

################################## echo ##################################

# :stopdoc:
ECHO_LINE = __LINE__ + 2
ECHO = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
echo '<%= args.join(" ") %>'
END_OF_TEMPLATE
# :startdoc:

# Echos inputs.
# ==== ECHO ERB
#   echo '<%= args.join(" ") %>'
def echo(*args)
  eval(ECHO, binding, __FILE__, ECHO_LINE)
  nil
end

def _echo(*args, &block) # :nodoc:
  capture { echo(*args, &block) }
end

########################## exists_check ##########################

# :stopdoc:
EXISTS_CHECK_LINE = __LINE__ + 2
EXISTS_CHECK = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
[ -e "<%= path %>" ]
END_OF_TEMPLATE
# :startdoc:

# 
# ==== EXISTS_CHECK ERB
#   [ -e "<%= path %>" ]
def exists?(path)
  eval(EXISTS_CHECK, binding, __FILE__, EXISTS_CHECK_LINE)
  nil
end

def _exists?(*args, &block) # :nodoc:
  capture { exists?(*args, &block) }
end

################################## ln_s ##################################

# :stopdoc:
LN_S_LINE = __LINE__ + 2
LN_S = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
ln -sf "<%= source %>" "<%= target %>"
<% check_status %>

END_OF_TEMPLATE
# :startdoc:

# 
# ==== LN_S ERB
#   ln -sf "<%= source %>" "<%= target %>"
#   <% check_status %>
def ln_s(source, target)
  eval(LN_S, binding, __FILE__, LN_S_LINE)
  nil
end

def _ln_s(*args, &block) # :nodoc:
  capture { ln_s(*args, &block) }
end

################################ recipe ################################

# :stopdoc:
RECIPE_LINE = __LINE__ + 2
RECIPE = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
"<%= env_path %>" - "<%= shell_path %>" "<%= recipe_path(name) %>" $*
<% check_status %>

END_OF_TEMPLATE
# :startdoc:

# 
# ==== RECIPE ERB
#   "<%= env_path %>" - "<%= shell_path %>" "<%= recipe_path(name) %>" $*
#   <% check_status %>
def recipe(name)
  eval(RECIPE, binding, __FILE__, RECIPE_LINE)
  nil
end

def _recipe(*args, &block) # :nodoc:
  capture { recipe(*args, &block) }
end

#################################### rm ####################################

# :stopdoc:
RM_LINE = __LINE__ + 2
RM = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% only_if _exists?(path) do %>
rm<%= to_opts(opts) %> "<%= path %>"
<% end %>
END_OF_TEMPLATE
# :startdoc:

# 
# ==== RM ERB
#   <% only_if _exists?(path) do %>
#   rm<%= to_opts(opts) %> "<%= path %>"
#   <% end %>
def rm(path, opts={})
  eval(RM, binding, __FILE__, RM_LINE)
  nil
end

def _rm(*args, &block) # :nodoc:
  capture { rm(*args, &block) }
end

############################### section ###############################

# :stopdoc:
SECTION_LINE = __LINE__ + 2
SECTION = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% n = (76 - comment.length)/2 %>
<%= "#" * n %><%= comment %><%= "#" * n %>

END_OF_TEMPLATE
# :startdoc:

# 
# ==== SECTION ERB
#   <% n = (76 - comment.length)/2 %>
#   <%= "#" * n %><%= comment %><%= "#" * n %>
def section(comment="")
  eval(SECTION, binding, __FILE__, SECTION_LINE)
  nil
end

def _section(*args, &block) # :nodoc:
  capture { section(*args, &block) }
end

############################### shebang ###############################

# :stopdoc:
SHEBANG_LINE = __LINE__ + 2
SHEBANG = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
#! <%= shell_path %>

<%= section %>
<%= check_status_function %>

export -f check_status
export LINECOOK_DIR=$(dirname $0)
export LINECOOK_OPTIONS=

while getopts bhvx opt
do
  case $opt in
  v)  LINECOOK_OPTIONS="$LINECOOK_OPTIONS -v";;
  x)  LINECOOK_OPTIONS="$LINECOOK_OPTIONS -x";;
  h)  printf "Usage: %s: [-hvx]\n" $0
      printf "  -h    prints this help\n"
      printf "  -v    verbose (set -v)\n"
      printf "  -x    xtrace  (set -x)\n"
      exit 0;;
  ?)  printf "Usage: %s: [-hvx]\n" $0
      exit 2;;
  esac
done

set $LINECOOK_OPTIONS > /dev/null
<%= section " #{target_name} " %>

END_OF_TEMPLATE
# :startdoc:

# == Notes
# Use dev/null on set such that no options will not dump ENV into stdout.
# ==== SHEBANG ERB
#   #! <%= shell_path %>
#   
#   <%= section %>
#   <%= check_status_function %>
#   
#   export -f check_status
#   export LINECOOK_DIR=$(dirname $0)
#   export LINECOOK_OPTIONS=
#   
#   while getopts bhvx opt
#   do
#     case $opt in
#     v)  LINECOOK_OPTIONS="$LINECOOK_OPTIONS -v";;
#     x)  LINECOOK_OPTIONS="$LINECOOK_OPTIONS -x";;
#     h)  printf "Usage: %s: [-hvx]\n" $0
#         printf "  -h    prints this help\n"
#         printf "  -v    verbose (set -v)\n"
#         printf "  -x    xtrace  (set -x)\n"
#         exit 0;;
#     ?)  printf "Usage: %s: [-hvx]\n" $0
#         exit 2;;
#     esac
#   done
#   
#   set $LINECOOK_OPTIONS > /dev/null
#   <%= section " #{target_name} " %>
def shebang
  eval(SHEBANG, binding, __FILE__, SHEBANG_LINE)
  nil
end

def _shebang(*args, &block) # :nodoc:
  capture { shebang(*args, &block) }
end
end
end
end
