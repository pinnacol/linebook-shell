require 'erb'

# Generated by Linecook, do not edit.
module Linebook
module Shell
module Unix
require 'linebook/shell/posix'
include Posix

def shell_path
  @shell_path ||= '/bin/sh'
end

def env_path
  @env_path ||= '/usr/bin/env'
end

def target_path(source_path)
  '$LINECOOK_DIR/%s' % super(source_path)
end

def close
  unless closed?
    section " (#{target_name}) "
  end
  
  super
end
################################### cat ###################################

# Executes 'cat' with the sources.
def cat(*sources)
  cmd 'cat', *sources
end

def _cat(*args, &block) # :nodoc:
  capture { cat(*args, &block) }
end

################################# chmod #################################

# :stopdoc:
CHMOD_LINE = __LINE__ + 2
CHMOD = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% if mode %>
chmod <%= mode %> <%= quote(target) %>
<% check_status %>
<% end %>
END_OF_TEMPLATE
# :startdoc:

# 
# ==== CHMOD ERB
#   <% if mode %>
#   chmod <%= mode %> <%= quote(target) %>
#   <% check_status %>
#   <% end %>
def chmod(mode, target)
  eval(CHMOD, binding, __FILE__, CHMOD_LINE)
  nil
end

def _chmod(*args, &block) # :nodoc:
  capture { chmod(*args, &block) }
end

################################# chown #################################

# :stopdoc:
CHOWN_LINE = __LINE__ + 2
CHOWN = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% if user || group %>
chown <%= user %>:<%= group %> <%= quote target %>
<% check_status %>
<% end %>
END_OF_TEMPLATE
# :startdoc:

# 
# ==== CHOWN ERB
#   <% if user || group %>
#   chown <%= user %>:<%= group %> <%= quote target %>
#   <% check_status %>
#   <% end %>
def chown(user, group, target)
  eval(CHOWN, binding, __FILE__, CHOWN_LINE)
  nil
end

def _chown(*args, &block) # :nodoc:
  capture { chown(*args, &block) }
end

#################################### cp ####################################

# 
def cp(source, target)
  cmd 'cp', source, target
end

def _cp(*args, &block) # :nodoc:
  capture { cp(*args, &block) }
end

################################## cp_f ##################################

# 
def cp_f(source, target)
  cmd 'cp', '-f', source, target
end

def _cp_f(*args, &block) # :nodoc:
  capture { cp_f(*args, &block) }
end

################################## cp_r ##################################

# 
def cp_r(source, target)
  cmd 'cp', '-r', source, target
end

def _cp_r(*args, &block) # :nodoc:
  capture { cp_r(*args, &block) }
end

####################### directory_check #######################

# :stopdoc:
DIRECTORY_CHECK_LINE = __LINE__ + 2
DIRECTORY_CHECK = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
[ -d "<%= path %>" ]
END_OF_TEMPLATE
# :startdoc:

# 
# ==== DIRECTORY_CHECK ERB
#   [ -d "<%= path %>" ]
def directory?(path)
  eval(DIRECTORY_CHECK, binding, __FILE__, DIRECTORY_CHECK_LINE)
  nil
end

def _directory?(*args, &block) # :nodoc:
  capture { directory?(*args, &block) }
end

########################## exists_check ##########################

# :stopdoc:
EXISTS_CHECK_LINE = __LINE__ + 2
EXISTS_CHECK = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
[ -e "<%= path %>" ]
END_OF_TEMPLATE
# :startdoc:

# 
# ==== EXISTS_CHECK ERB
#   [ -e "<%= path %>" ]
def exists?(path)
  eval(EXISTS_CHECK, binding, __FILE__, EXISTS_CHECK_LINE)
  nil
end

def _exists?(*args, &block) # :nodoc:
  capture { exists?(*args, &block) }
end

############################ file_check ############################

# :stopdoc:
FILE_CHECK_LINE = __LINE__ + 2
FILE_CHECK = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
[ -f "<%= path %>" ]
END_OF_TEMPLATE
# :startdoc:

# 
# ==== FILE_CHECK ERB
#   [ -f "<%= path %>" ]
def file?(path)
  eval(FILE_CHECK, binding, __FILE__, FILE_CHECK_LINE)
  nil
end

def _file?(*args, &block) # :nodoc:
  capture { file?(*args, &block) }
end

#################################### ln ####################################

# 
def ln(source, target)
  cmd 'ln', source, target
end

def _ln(*args, &block) # :nodoc:
  capture { ln(*args, &block) }
end

################################## ln_s ##################################

# 
def ln_s(source, target)
  cmd 'ln', '-s', source, target
end

def _ln_s(*args, &block) # :nodoc:
  capture { ln_s(*args, &block) }
end

################################# mkdir #################################

# Make a directory
def mkdir(path)
  cmd 'mkdir', path
end

def _mkdir(*args, &block) # :nodoc:
  capture { mkdir(*args, &block) }
end

############################### mkdir_p ###############################

# Make a directory, and parent directories as needed.
def mkdir_p(path)
  cmd 'mkdir', '-p', path
end

def _mkdir_p(*args, &block) # :nodoc:
  capture { mkdir_p(*args, &block) }
end

#################################### mv ####################################

# 
def mv(source, target)
  cmd 'mv', source, target
end

def _mv(*args, &block) # :nodoc:
  capture { mv(*args, &block) }
end

################################## mv_f ##################################

# 
def mv_f(source, target)
  cmd 'mv', '-f', source, target
end

def _mv_f(*args, &block) # :nodoc:
  capture { mv_f(*args, &block) }
end

#################################### rm ####################################

# Unlink a file.
def rm(path)
  cmd 'rm', path
end

def _rm(*args, &block) # :nodoc:
  capture { rm(*args, &block) }
end

################################## rm_r ##################################

# Unlink a file or directory.
def rm_r(path)
  cmd 'rm', '-r', path
end

def _rm_r(*args, &block) # :nodoc:
  capture { rm_r(*args, &block) }
end

################################# rm_rf #################################

# Unlink a file or directory, forcefully.
def rm_rf(path)
  cmd 'rm', '-rf', path
end

def _rm_rf(*args, &block) # :nodoc:
  capture { rm_rf(*args, &block) }
end

############################### section ###############################

# :stopdoc:
SECTION_LINE = __LINE__ + 2
SECTION = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
<% n = (76 - comment.length)/2 %>
<%= "#" * n %><%= comment %><%= "#" * n %>

END_OF_TEMPLATE
# :startdoc:

# 
# ==== SECTION ERB
#   <% n = (76 - comment.length)/2 %>
#   <%= "#" * n %><%= comment %><%= "#" * n %>
def section(comment="")
  eval(SECTION, binding, __FILE__, SECTION_LINE)
  nil
end

def _section(*args, &block) # :nodoc:
  capture { section(*args, &block) }
end

############################### shebang ###############################

# :stopdoc:
SHEBANG_LINE = __LINE__ + 2
SHEBANG = "self." + ERB.new(<<'END_OF_TEMPLATE', nil, '<>').src
#! <%= shell_path %>

<%= section %>
<%= check_status_function %>

export -f check_status
export LINECOOK_DIR=$(dirname $0)
export LINECOOK_OPTIONS=

while getopts bhvx opt
do
  case $opt in
  v)  LINECOOK_OPTIONS="$LINECOOK_OPTIONS -v";;
  x)  LINECOOK_OPTIONS="$LINECOOK_OPTIONS -x";;
  h)  printf "Usage: %s: [-hvx]\n" $0
      printf "  -h    prints this help\n"
      printf "  -v    verbose (set -v)\n"
      printf "  -x    xtrace  (set -x)\n"
      exit 0;;
  ?)  printf "Usage: %s: [-hvx]\n" $0
      exit 2;;
  esac
done

set $LINECOOK_OPTIONS > /dev/null
<%= section " #{target_name} " %>

END_OF_TEMPLATE
# :startdoc:

# == Notes
# Use dev/null on set such that no options will not dump ENV into stdout.
# 
# ==== SHEBANG ERB
#   #! <%= shell_path %>
#   
#   <%= section %>
#   <%= check_status_function %>
#   
#   export -f check_status
#   export LINECOOK_DIR=$(dirname $0)
#   export LINECOOK_OPTIONS=
#   
#   while getopts bhvx opt
#   do
#     case $opt in
#     v)  LINECOOK_OPTIONS="$LINECOOK_OPTIONS -v";;
#     x)  LINECOOK_OPTIONS="$LINECOOK_OPTIONS -x";;
#     h)  printf "Usage: %s: [-hvx]\n" $0
#         printf "  -h    prints this help\n"
#         printf "  -v    verbose (set -v)\n"
#         printf "  -x    xtrace  (set -x)\n"
#         exit 0;;
#     ?)  printf "Usage: %s: [-hvx]\n" $0
#         exit 2;;
#     esac
#   done
#   
#   set $LINECOOK_OPTIONS > /dev/null
#   <%= section " #{target_name} " %>
def shebang()
  attributes 'linebook/shell'
  if shell_module = attrs[:linebook][:shell][:module]
    helpers shell_module
  end
  eval(SHEBANG, binding, __FILE__, SHEBANG_LINE)
  nil
end

def _shebang(*args, &block) # :nodoc:
  capture { shebang(*args, &block) }
end
end
end
end
